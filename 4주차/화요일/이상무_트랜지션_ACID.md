# 트랜잭션과 ACID

## 목차

> 1. 트랜잭션이란?
>
> 2. 트랜잭션의 주요 속성
>
> 3. 트랜잭션과 ACID 원칙
>
> 4. 트랜잭션 격리 수준
>
> 5. 결론

---

## 1. 트랜잭션이란?

`트랜잭션(Transaction)`이란 데이터베이스의 상태를 변화시키는 하나의 작업 단위 또는 연산 집합을 의미합니다.

트랜잭션은 데이터베이스의 **일관성과 무결성을 보장**하기 위해 사용되며, 다음과 같은 작업을 포함할 수 있습니다.

- 데이터의 삽입 (INSERT)
- 데이터의 삭제 (DELETE)
- 데이터의 수정 (UPDATE)
- 데이터의 조회 (SELECT)

### 트랜잭션의 예시

은행에서의 송금 과정을 예로 들어보자자.

1. 계좌 A에서 10만 원을 인출한다.
2. 계좌 B에 10만 원을 입금한다.

이 두 가지 작업은 **단일 트랜잭션**으로 처리되어야 합니다. 만약 계좌 A에서 돈이 인출된 상태에서 오류가 발생하여 계좌 B에 입금이 실패한다면, 이는 데이터 무결성을 해칠 수 있습니다. 따라서 이러한 작업은 **트랜잭션**으로 묶여야 하며, 작업이 모두 성공하거나, 모두 실패해야 합니다.

**데이터 무결성이란 ?** 

데이터 무결성이란 조직의 데이터가 라이프사이클의 어느 시점에서든 정확하고 완전하며 일관성이 있다는 것을 보장하는 것

---

## 2. 트랜잭션의 주요 속성

트랜잭션은 ACID라는 네 가지 속성을 충족해야 합니다. 각각의 속성은 데이터의 신뢰성과 일관성을 보장하기 위해 중요한 역할을 합니다.

### 1) Atomicity (원자성)

- **설명**: 트랜잭션에 포함된 모든 연산이 **전부 성공**하거나 **전부 실패**해야 함을 보장합니다.
- **예시**:
  - 계좌 A에서 10만 원 인출이 성공했지만, 계좌 B에 입금이 실패한다면 트랜잭션 전체를 취소하고, 계좌 A의 상태도 롤백됩니다.
- **핵심 포인트**: "**부분적으로 완료되지 않음**."

### 2) Consistency (일관성)

- **설명**: 트랜잭션이 실행된 후 데이터베이스는 항상 **일관된 상태**를 유지해야 합니다.
- **예시**:
  - 송금 후 계좌 A와 계좌 B의 합산 금액은 트랜잭션 전후로 동일해야 합니다.
- **핵심 포인트**: "**데이터 무결성을 유지**."

### 3) Isolation (고립성) **중요 !**

- **설명**: 여러 트랜잭션이 동시에 실행될 때, 각각의 트랜잭션은 서로 간섭하지 않아야 합니다.
- **예시**:
  - 계좌 A에서 돈을 이체하는 트랜잭션이 진행 중일 때, 다른 트랜잭션이 계좌 A를 읽거나 수정하지 못하게 막습니다.
- **핵심 포인트**: "**동시 실행에도 불구하고 독립적**."

### 4) Durability (영속성)

- **설명**: 트랜잭션이 성공적으로 완료되면, 시스템 장애가 발생하더라도 해당 결과는 데이터베이스에 **영구적으로 반영**되어야 합니다.
- **예시**:
  - 송금이 완료된 후 시스템이 재부팅되더라도 송금 내역은 데이터베이스에 남아 있어야 합니다.
- **핵심 포인트**: "**완료된 트랜잭션의 결과는 영구적**."

### 여기서 고립성 부분을 보자. 

"트랜잭션은 독립적으로 실행되어야 하며, 다른 트랜잭션에 영향을 주어서도 안되고, 영향을 받아서도 안된다." 이 말인 즉슨 ! 같은 데이터를 수정하게 되는 트랜잭션이 존재 시, 순차적으로 처리해야 고립성을 만족하게 된다는 뜻이다.

이것은 현실적으로 성능 상 단점이 될 수 있다.

만약 현업에서 10만개의 데이터(트랜잭션)를 수행한다고 하면, 10만 개의 데이터를 순차적으로 처리하게 되므로 시간이 굉장히 오래 소요될 것이다. 

따라서 현실과의 타협을 위해 트랜잭션에서는 네 가지 고립 수준을 소개하고 있다.

고립 수준은 어떤 것들이 있을지, 어떤 상황에서 쓰면 좋을지, 각각의 고립 수준에서 나타날 수 있는 문제점과 그 해결 방법은 무엇이 있을지 본격적으로 살펴보자.



## 3. 트랜잭션 격리 수준

트랜잭션의 격리성은 동시성 문제를 방지하는 데 중요한 역할을 합니다. 데이터베이스 관리 시스템은 다음과 같은 격리 수준을 제공합니다.

### 1) Read Uncommitted (읽기 미완료 허용)
- **설명**: 다른 트랜잭션에서 커밋되지 않은 데이터를 읽을 수 있음.
- **문제점**: Dirty Read (더티 리드) 발생 가능.

**커밋**이란 ? 

커밋(commit)은 데이터베이스 트랜잭션의 중요한 단계로, 트랜잭션에서 수행된 작업(수정, 추가, 삭제 등)을 데이터베이스에 영구적으로 적용하는 것을 의미합니다.

커밋의 역할에는 영구 저장, 트랜잭션 종료, 일관성 유지 등이 있다.

예시를 통해 Read Uncommitted에 대해 더 알아보자.

![Read Uncommitted](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbdcUVY%2FbtsGiri2arM%2F1hZBj31bSm3iFkM7nMhQEk%2Fimg.png)

1. DB에는 10만원이 든 계좌가 있다.
2. 이 상태에서 트랜잭션 A가 읽기 요청을 수행한다.
3. DB에서는 계좌에 있는 금액 그대로 10만원을 반환하게 된다.
4. 이후 트랜잭션 A에서 5만원을 추가한다.
5. 이 때 DB는 10만원 > 15만원으로 금액이 변경된다.
6. 그 다음 트랜잭션 B가 읽기 요청을 수행한다.
7. 이때 Read Uncommitted는 아직 커밋되지 않은 데이터를 읽을 수 있으므로, 15만원을 반환한다. (트랜잭션 A는 아직 커밋이 되지 않은 상태)

근데 여기서 만약 트랜잭션 A에서 오류가 발생해서 롤백이 된다면?
DB에서는 10만원으로 기록되어 있는데, 트랜잭션 B에서 반환하는 값은 (15만원)이 되는 현상이 발생한다.
이렇게 되면 둘의 값이 달라지기 때문에 일관성 문제가 발생하게 된다.

이 문제를 **Dirty Read**라고 한다. 더티 리드는, 특정 트랜잭션에서 데이터를 변경했지만 아직 커밋되지 않았을 때, 다른 트랜잭션이 해당 값을 조회할 수 있는 문제이다.

어떻게 해결할까 ? 커밋된 데이터만 읽을 수 있도록 하면 된다.

### 2) Read Committed (읽기 커밋 허용)
- **설명**: 위에서 설명한 더티 리드의 해결방법 대로, READ-COMMITTED는 커밋된 데이터만 읽을 수 있도록 한 설정이다.
- **문제점**: Non-repeatable Read (비반복적 읽기) 발생 가능.

![Read Committed](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbI4Fkz%2FbtsGis93VsJ%2FjIkd1eKR5F5wBetydrT8sK%2Fimg.png)

여기서도 문제가 발생할 수 있다.

1번 ~ 6번 까지의 과정은 Read Uncommitted 방식과 동일하다.
하지만 Read Committed의 경우 커밋된 데이터만 읽을 수 있으므로, 트랜잭션 A가 커밋되지 않은 상태에서 트랜잭션 B가 읽기 요청을 보내면 10만원을 반환하게 된다. --> Dirty read 문제 해결

하지만 여기서 발생할 수 있는 문제점이 또 있다.

![Read Committed error](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FttOwv%2FbtsGisI0DcF%2FIYYzNuepJrTgnHs1vzw1UK%2Fimg.png)

8. 트랜잭션 A가 커밋을 한다.
9. 그 후 트랜잭션 B가 읽기 요청을 하면, 커밋된 데이터를 읽으므로 15만원을 반환할 겅시다.
10. 이때 트랜잭션 B는 같은 데이터를 요청했지만 다른 데이터를 반환받으므로 문제가 발생한다.

이 문제를 Non-Repeatable-Read 라고 한다.

논 리피터블 리드 문제란, **트랜잭션 내에서 같은 데이터를 여러 번 조회할 때 읽은 데이터가 서로 다른 값으로 나오는 문제**를 말한다.

이 문제는 다음 고립 수준을 통해 해결할 수 있다.

### 3) Repeatable Read (반복 가능한 읽기)
- **설명**: 동일 트랜잭션 내에서 같은 데이터를 여러 번 읽어도 일관된 결과 제공.
- **문제점**: Phantom Read (팬텀 리드) 발생 가능.

예시를 통해 알아보자.

![Repetable Read](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcSAuF9%2FbtsGhV5Wek7%2Fon3GhUcGoqbxUat43J9cPk%2Fimg.png)

1 ~ 8번째까지의 과정은 전 단계와 같다. 이후 트랜잭션 B가 DB로 읽기 요청을 했을 때, 6번에서 조회한 데이터를 9번에서 반복 조회하는 것이므로 같은 값인 10만원을 반환한다. --> Non-Repetable-Read 문제 해결

하지만 문제점이 또 있을 수 있다.

![Phantom Read](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcakKI4%2FbtsGh6lRZji%2FsDEgEIoGuCS5rrYN9qkzP1%2Fimg.png)

1. DB에 10만원이 든 계좌가 한 개 있는 상태에서 은행 계좌의 갯수를 세는 쿼리를 날린다.
2. 계좌가 한 개 있으니 1개를 반환한다.
3. 이 때 트랜잭션 A가 새로운 5만원이 든 계좌를 추가한다.
4. 그럼 DB에는 10만원 계좌, 5만원 계좌 총 2개가 생긴다.
5. 이 때 트랜잭션 B가 이전에 요청했던 계좌 개수를 세는 쿼리를 날린다.
6. 그럼 2개가 반환된다. 같은 요청을 했는데 첫 번째는 1이 나오고, 두 번째는 2가 나온다.

위와 같은 문제를 팬텀 리드 문제라고 한다. 

팬텀 리드란 Non-Repeatable-Read의 한 종류로, 새로운 데이터가 생기거나, 기존의 데이터가 사라지는 문제를 말한다. 


### 4) Serializable (직렬화 가능)
- **설명**: 가장 높은 수준의 격리, 트랜잭션이 순차적으로 실행되는 것처럼 동작.
- **문제점**: 성능 저하 가능.

그림을 통해 알아보자.

![Serializable](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fc4N9yY%2FbtsGj3uGhIX%2FwLTEjKRGUkW62PPm6W7a30%2Fimg.png)
---

위 예시를 보면, 트랜잭션 A는 READ와 WRITE를 수행한 후 커밋을 한다. (1 ~ 6번)

그 이후가 되서야 트랜잭션 B가 DB에 읽기 요청을 하고 (7번), 15만원을 반환한 상태(8번) 에서 커밋을 할 수 있다.

즉, 트랜잭션 A가 끝나고 나서야 순차적으로 B가 수행된다는 것이다.

## 4. 결론

트랜잭션과 ACID 원칙은 데이터베이스의 무결성과 신뢰성을 유지하기 위한 필수 개념입니다. 특히, 데이터 무결성이 중요한 애플리케이션에서는 트랜잭션을 적절히 설계하여 신뢰할 수 있는 서비스를 제공해야 합니다.

**요약**

| 속성         | 역할                                                                                     |
|--------------|-----------------------------------------------------------------------------------------|
| Atomicity    | 작업의 올바른 완료 보장                                                                  |
| Consistency  | 데이터의 유효성과 무결성 유지                                                             |
| Isolation    | 동시성 문제 방지 및 독립적 작업 환경 제공                                                  |
| Durability   | 시스템 장애 시에도 데이터 영속성 유지                                                     |

![격리 수준](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FltDIn%2FbtsGj3VLUT5%2FqpLKohuxEKbc20ljawkhw1%2Fimg.png)

위로 올라갈수록 속도는 빠르지만 데이터의 일관성을 보장하지 못하고, 밑으로 갈수록 속도는 느리지만 데이터의 일관성을 보장할 수 있다.

따라서, 데이터베이스 설계 단계에서 트랜잭션 관리와 ACID 속성을 고려하여 효율적이고 신뢰성 높은 데이터베이스 시스템을 구축하는 것이 중요합니다.

