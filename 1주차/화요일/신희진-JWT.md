# JWT(Json Web Token)

## JWT란 무엇일까?

- **JWT**는 JSON 형식의 데이터를 웹 표준(RFC 7519)에 따라 안전하게 전송하기 위한 토큰입니다.
- **Self-Contained(자가 수용적)**: 필요한 모든 정보를 자체적으로 포함하여 서버가 별도로 상태를 저장할 필요가 없습니다.
- 주로 **인증(Authentication)**과 **정보 교류(Information Exchange)**에 사용됩니다.
![JWT1.png](JWT1.png)
---

## JWT의 등장!

JWT는 기존 **Cookie와 Session 기반 인증 체계**의 문제점들을 해결하기 위해 등장했습니다.

그렇다면 쿠키와 세션이 왜 등장했으며, 어떤 문제점들을 가지고 있는지 알아보겠습니다.

---

## **그전에 쿠키와 세션은 왜 나오게 되었을까?**

### HTTP의 한계

- **HTTP**는 서버와 클라이언트 간 데이터를 주고받기 위해 설계된 비연결성(Connectionless) 및 무상태성(Stateless)의 특성을 가진 프로토콜입니다.
    - **비연결성**: 요청과 응답이 끝나면 연결을 끊음으로써 자원을 절약합니다.
    - **무상태성**: 이전 요청의 상태를 기억하지 않아 클라이언트를 식별할 수 없습니다.
- 이러한 특성은 자원을 절약하는 데 유리하지만, 다음과 같은 문제가 발생합니다:
    - **서버가 클라이언트를 기억하지 못함**: 매 요청마다 인증 정보를 반복적으로 제공해야 하는 불편함.
    - **사용자 경험 저하**: 브라우저를 새로고침하거나 다른 페이지로 이동할 때마다 재인증이 필요.

이 문제를 해결하기 위해 **쿠키(Cookie)**와 **세션(Session)** 기반 인증이 도입되었습니다.

---

## Cookie

### 쿠키란?

- 쿠키는 서버가 클라이언트의 브라우저에 저장하는 작은 기록 정보 파일입니다.
- 클라이언트의 상태 정보를 클라이언트 측에 저장하여 필요 시 서버가 이를 참조하거나 재사용할 수 있도록 합니다.

### **쿠키의 동작 순서**

1. **클라이언트가 페이지를 요청**: 사용자가 웹사이트에 접속합니다.
2. **웹 서버가 쿠키 생성**: 서버는 사용자 정보를 포함한 쿠키를 생성합니다.
3. **쿠키 전송 및 저장**: 서버는 HTTP 응답에 쿠키를 포함하여 클라이언트에 보냅니다.클라이언트는 이를 로컬 저장소에 저장합니다.
4. **요청 시 쿠키 전송**: 클라이언트는 이후 요청마다 저장된 쿠키를 서버로 전송합니다.
5. **서버가 쿠키를 사용해 식별**: 서버는 쿠키 정보를 바탕으로 클라이언트를 식별합니다.

---

## Cookie & Session 기반 인증
![서버 기반 인증 동작 방식](Server.png)
### 문제점

- 쿠키를 사용하면 클라이언트의 로그인 상태를 유지할 수 있지만, 다음과 같은 문제점이 있습니다:
    - **보안 취약성**: 쿠키는 클라이언트 측에 저장되므로 탈취되거나 조작될 위험이 있습니다.
    - **네트워크 부하**: 요청마다 쿠키를 전송하므로 대량의 데이터가 있을 경우 성능 저하가 발생합니다.

### 세션의 등장

- 세션은 쿠키의 보안 문제를 해결하기 위해 고안된 방식으로, **사용자 인증 정보를 서버 측에 저장**합니다.
- 세션은 다음과 같은 방식으로 동작합니다:
    1. 사용자가 로그인하면 서버는 인증 정보를 저장하고 고유한 **세션 ID**를 생성합니다.
    2. 클라이언트는 세션 ID를 쿠키에 저장하여 서버에 전달합니다.
    3. 서버는 요청마다 세션 ID를 확인해 사용자를 식별합니다.

### 세션의 장단점

**장점**:

- 인증 정보를 서버에 저장하므로 보안성이 우수합니다.
- 클라이언트가 민감한 정보를 직접 관리하지 않아도 됩니다.

**단점**:

- **서버 부하 증가**: 모든 사용자 세션 데이터를 서버가 관리하므로 자원 소모가 큽니다.
- **확장성 문제**: 서버를 여러 대로 확장하려면 세션 데이터를 공유해야 하며, 이는 설계가 복잡합니다.

---

## JWT의 필요성과 등장

세션 기반 인증은 보안성은 우수하지만 다음과 같은 문제점이 있었습니다:

1. 서버가 상태를 유지해야 하는 **Stateful** 구조로 인해 확장성이 떨어집니다.
2. 다중 서버 환경에서는 세션 데이터를 동기화해야 하며, 이는 복잡성을 증가시킵니다.
3. Cross-Origin 문제로 인해 여러 도메인 간 인증 정보를 공유하기 어렵습니다.
4. "매번" 요청시 세션 저장소에 세션 ID를 조회하는 작업을 통해 DB를 접근하는 로직이 수행됩니다.
이러한 문제를 해결하기 위해 **JWT(Json Web Token)**가 등장했습니다. JWT는 서버가 상태를 저장하지 않아도 되는 **Stateless** 구조로 확장성이 뛰어나며, 다양한 환경에서 인증 정보를 효율적으로 관리할 수 있습니다.

---

## JWT의 구조
- JWT는 말그대로 인증에 필요한 정보들을 Token에 담아 암호화시켜 사용하는 토큰입니다.
- 따라서 기본적인 인증을 진행하는 구조는 Cookie와 비슷합니다.
- 다만, JWT는 **서명된 토큰**입니다.
- 공개/개인 키를 쌍으로 사용하여 토큰에 서명할 경우 서명된 토큰은 개인 키를 보유한 서버가 이 서명된 토큰이 정상적인 토큰인지 확인할 수 있습니다.

##### JWT 각각의 구성요소가 점(.)으로 구분이 되어있으며 세 부분으로 구성됩니다.
![JWT.png](JWT.png)
1. **Header**:
    - 토큰 타입(JWT)과 서명 알고리즘 정보를 포함합니다.
    - 아래의 경우 토큰타입은 JWT이고, 개인키로 HS256 알고리즘이 적용되어 암호화 되어있음을 확인할 수 있습니다.
    
    ```json
    { "typ": "JWT", "alg": "HS256" }
    
    ```
    
2. **Payload**:
    - 사용자 정보(예: 사용자 ID)와 토큰 만료 시간 등을 포함합니다.
    - 각 데이터는 **Claim(클레임)**이라고 불리며, Key-Value 형식으로 저장됩니다.
    - JWT 표준스펙
      - iss: 토큰발급자
      - sub: 토큰제목
      - aud: 토큰 대상자
      - exp: 토큰 말료시간
      - nbf: 토큰활성날짜
      - iat: 토큰 발급시간
      - jti: JWT 토큰 식별자
    - 꼭 7가지를 모두 포함해야 하는것은 아니고, 상황에 따라 서버거 가져야 할 인증 체계에 맞춰 사용하면 됩니다.
   
    ```json
    {
      "sub": "user123",
      "iss": "ori",
      "exp": 1717171717,
      "iat": 1636987918
    }
    
    ```
    
3. **Signature**:
    - Header와 Payload를 비밀키로 해싱하여 생성한 서명입니다.
    - Header와 Payload를 보여줄 때는 인코딩 되어있던 값들을 JWT에 담겨 있는것 처럼 디코딩된 상태를 사용합니다.
    - header를 디코딩, payload를 디코딩한 값을 합치고 이를 서버가 가지고 있는 개인키를 가지고 암호화 되어 있습니다.
    - 따라서 signature는 서버에 있는 개인키만으로 암호화를 풀 수 있으므로 다른 클라이언트는 임의로 복호화할 수 없습니다.
    ![Signature.png](Signature.png)
    ```
    HMACSHA256(
      base64UrlEncode(header) + "." + base64UrlEncode(payload),
      secret
    )
    
    ```
    **생성과정**
    1. **Header와 Payload를 인코딩**
   - Header와 Payload는 각각 Base64 URL-safe 방식으로 인코딩됩니다.
     - 예시:
        
         ```plaintext
         Header:  eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9
         Payload: eyJzdWIiOiJ1c2VyMTIzIiwiZXhwIjoxNzE3MTcxNzE3fQ
        
         ```
        
   2. **Header와 Payload를 연결**
       - Header와 Payload를 `.`으로 연결합니다.
        
           ```plaintext
           Header.Payload
        
           ```
        
   3. **Signature 생성**
       - 서버는 이 연결된 문자열을 **비밀키(secret)**와 함께 서명 알고리즘(HMAC SHA256 등)을 사용하여 암호화합니다.
        
           ```plaintext

           Signature = HMACSHA256(Header.Payload, secret)
        
           ```
        
   4. **JWT 최종 구성**
       - Header, Payload, Signature를 `.`으로 구분하여 최종 JWT가 생성됩니다.
        
           ```plaintext
           eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ1c2VyMTIzIiwiZXhwIjoxNzE3MTcxNzE3fQ.sqKAO-0fCJA8X9-L7JBlxKdS7yoW3ZrTDJ5d5Nfp4CQ
        
           ```
        

---

### **Signature 검증 과정**

서버는 클라이언트가 보낸 JWT의 Signature를 다음과 같이 검증합니다:

1. **클라이언트 요청**
    - 클라이언트는 JWT를 Authorization 헤더에 포함해 서버로 요청을 보냅니다:
        
        ```
        plaintext
        복사
        Authorization: Bearer <JWT>
        
        ```
        
   1. **서버가 Header와 Payload를 분리**
       - 서버는 JWT를 받아 Header와 Payload를 Base64 디코딩합니다.
   2. **Signature 재생성**
       - 서버는 클라이언트가 보낸 Header와 Payload를 연결하여 새로운 Signature를 생성합니다:
        
           ```
           plaintext
           복사
           HMACSHA256(Header.Payload, secret)
        
           ```
        
   3. **Signature 비교**
       - 클라이언트가 보낸 Signature와 서버에서 생성한 Signature를 비교합니다:
           - **일치**: 토큰이 변조되지 않았으므로 인증 허용.
           - **불일치**: 토큰이 변조되었으므로 인증 거부.

---

### **Signature의 역할**

Signature의 역할은 다음과 같습니다:

- **토큰 변조 방지**: 클라이언트가 Payload를 변조하더라도, 서버에서 생성한 Signature와 일치하지 않아 요청이 거부됩니다.
  - **안전한 인증**: 비밀키를 가진 서버만 Signature를 생성하거나 검증할 수 있으므로, 클라이언트가 임의로 서명을 만들 수 없습니다.

---

## JWT vs Cookie/Session

| **항목** | **Cookie/Session 기반 인증** | **JWT 기반 인증** |
| --- | --- | --- |
| **저장 위치** | 서버(Session) + 클라이언트(Cookie) | 클라이언트 |
| **서버 상태** | Stateful | Stateless |
| **Cross-Origin** | 제한적 | 가능 |
| **확장성** | 낮음 | 높음 |
| **보안성** | 높음 | 중간 (서명으로 위변조 방지) |
| **토큰 길이** | 짧음 | 비교적 길다 |
![JWT vs Cookie/Session.png](JWT-CookieSession.png)
---

## JWT의 장단점

**장점**:

1. 서버가 상태를 저장하지 않아 **확장성**이 뛰어납니다.
2. 이미 토큰 자체가 인증된 정보이므로 세션 저장소와 같은 별도의 인증 저장소가 필요하지 않습니다.
3. 서명을 통해 **위변조 방지**가 가능합니다.
4. 클라이언트가 인증 정보를 관리하므로 서버 자원을 절약할 수 있습니다.
5. 다양한 플랫폼 및 환경에서 사용 가능합니다.

**단점**:

1. **Payload 노출**: Base64 인코딩만 적용되므로 민감한 데이터를 포함하면 안 됩니다.
2. **토큰 길이**: 클레임이 많아질수록 네트워크 부하가 발생할 수 있습니다.
3. **탈취 위험**: 토큰이 유출되면 만료 전까지 사용할 수 있습니다.


